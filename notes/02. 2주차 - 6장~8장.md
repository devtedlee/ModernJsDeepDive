# 6장 - 데이터 타입

데이터 타입의 종류

| 구분      | 데이터 타입       | 설명                                               |
| --------- | ----------------- | -------------------------------------------------- |
| 원시 타입 | 숫자 타입         | 숫자, 정수와 실수 구분없이 하나의 숫자 타입 존재   |
|           | 문자열 타입       | 문자열                                             |
|           | 불리언 타입       | 논리적 참과 거짓                                   |
|           | undefined 타입    | var 키워드로 선언된 변수에 암묵적으로 할당 되는 값 |
|           | null 타입         | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값  |
|           | 심벌(Symbol) 타입 | ES6에서 추기된 7번째 타입(추후 다룸)               |
|           | BigInt 타입       | 2^53-1 보다 큰 정수를 표현할 수 있는 새로운 원시값 |
| 객체 타입 |                   | 객체, 함수, 배열 등                                |

## 6.1 숫자 타입

- 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식을 따른다.
- 모든 수는 실수이며, 정수만 표현하기 위한 데이터 타입은 존재하지 않는다.
  - ❓BigInt와의 차이점을 알고 싶다. 그리고 정수만 표현하기 위한 타입일지도 알아보자
    - https://ko.javascript.info/bigint
      - 수학연산자 사용시 일반 숫자와 섞어서 불가
      - 비교 연산은 섞어서 가능
      - 섞었을 때 동등은 가능 일치는 불가능 10 === 10n
      - 논리 연산자에서 0n도 0과 마찬가지 falsy임
    - 확실한건 부동소수점 형식에서 벗어나서 다른 구현임

## 6.2 문자열 타입

- 0개 이상의 16비트 유니코드 문자의 집합. 전 세계 대부분의 문자를 표현할 수 있다.
  - ❓여기서 이모티콘의 취급과 왜 특수문자와 다르게 식별자로 사용가능한지 알아보자
    - 이모지는 유니코드에 속한 문자이기 때문에 가능
    - 특수문자들은 예약어나 키워드 같은 개념으로 쓰기 때문에 불가능하게 막아둔 거라고 함.
- 자바스크립트의 문자열은 원시 타입이며, 변경 불가능한 값이다.

## 6.3 템플릿 리터럴

### 6.3.1 멀티라인 문자열

- 일반 문자열에서는 줄바꿈을 하려면 백슬래시로 시작하는 이스케이프 시퀀스를 사용해야 한다.
- ❓이스케이프 시퀀스 정리

| 문자 | 설명        |
| ---- | ----------- |
| \n   | 개행        |
| \t   | 탭          |
| \b   | 백스페이스  |
| \r   | 캐리지 리턴 |
| `\'` | 작은 따옴표 |
| `\"` | 큰 따옴표   |

- 라인 피드(LF, Line Feed)와 캐리지 리턴(CR, Carriage Return)
  - 타자기에서 커서를 제어하던 방식에서 비롯됨
  - 윈도우의 경우 CR-LF를 사용중인데 초창기 컴퓨터 출력시 사용하던 패턴이 지속됐다.
  - 맥은 9버전까지 CR이었다가 이제 LF사용한다고 함.

### 6.3.2 표현식 삽입

- ${} 이걸로 삽입하는거

- ❓3대 요소로 태그드 템플릿 까지 언급됐는데 설명이 없다. 조사할 것
  - 태그를 사용해서 템플릿 리터럴을 함수로 파싱할 수 있는 기능
  - 예시

```Javascript
const food = 'cookie';
const taste = 'sweet';

function getTodayFood(str, food, taste) {
    const str0 = str[0]; // Today's snack is

    // cookie > ice cream
    if (food === 'cookie') {
        food = 'ice cream';
    }

    // sweet > salty
    if (taste === 'sweet') {
        taste = 'salty';
    }

    return str0 + food + ' ' + taste
}

const snacks = getTodayFood`Today's snack is ${food} ${taste}`;
console.log(snacks); // Today's snack is ice cream salty
```

## 6.4 불리언 타입

- 조건문에서 더 살펴봄

## 6.5 undefined 타입

- 자바스크립트 엔진이 변수를 초기화 할 때 사용하는 값
- 개발자가 의도적으로 변수에 할당한다면 undefined의 본래 취지에 어긋날뿐더러 혼란을 줄 수 있으므로 권장하지 않는다. 대신 null을 쓰자.
- 선언과 정의의 구분
  - 다른 언어는 선언과 정의를 실제로 메모리 주소를 할당하는가로 구분한다.
  - 자바스크립트의 경우 변수를 선언하면 암묵적으로 정의가 이뤄지기 떄문에 선언과 정의의 구분이 모호하다.
  - ECMASCript 사양에서는 변수는 '선언'하고, 함수는 '정의'한다고 표현한다.

## 6.6 null 타입

- 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미다. 이는 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것을 의마한다.

## 6.7 심벌 타입

- 변경 불가 원시 값이며, 다른 값과 중복 되지 않는 유일무이한 값.
- 33장에서 다시 다룰 예정

## 6.8 객체 타입

- 자바스크립트를 이루고 있는 거의 모든 것이 객체다. 11장에서 계속.

## 6.9 데이터 타입의 필요성

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
- 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

- 자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.
- ECMAScript 사양은 문자열과 숫자 타입 외의 데이터 타입의 크기를 명시적으로 규정하고 있지 않다. 그래서 엔진별로 다를 수 있다.
  - ❓문자열 크기 조사 필요
    - 글자당 n _ 2 바이트, 혹은 영어면 n _ 1바이트 이런식이고 엔진에 따라 고정 바이트일 수도 있기 때문에 유동적

### 6.9.2 데이터 타입에 의한 값의 해석

- 바이트 코드는 같아도 값의 해석에 따라 0100 0001 은 숫자면 65, 문자열은 A가 된다.

## 6.10 동적 타이핑

### 6.10.1 동적 타입 언어와 정적 타입 언어

- 자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정 된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.
- 기본적으로 변수는 타입을 갖지 않는다. 하지만 값은 타입을 갖는다.

### 6.10.2 동적 타입 언어와 변수

- 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.
- 변수 사용 주의 사항 5가지
  - 변수는 꼭 필요한 경우에만 제한적으로 사용: 숫자가 많아질수록 타입 잘못 예측해서 실수하기 쉬움
  - 변수의 유효 범위는 최대한 좁게 만들자
  - 전역 변수는 최대한 사용하지 말자: 덮어 씌워서 예상한 거랑 다르게 동작할 수 있다.
  - 변수보다는 상수를 사용하자
  - 변수 이름을 주의해서 네이밍 하자.
- 가독성 좋은 코드가 좋은 코드다.

# 7장 연산자

- 피연산자가 '값'이라는 명사의 역할을 한다면 연산자는 '피연산자를 연산하여 새로운 값을 만든다'라는 동사의 역할을 한다.

## 7.1 산술 연산자

- 산술 연산이 불가능한 경우, NaN을 반환한다.

| 연산자     | 종류                     | 의미                                                        | 부수 <br>효과 |
| ---------- | ------------------------ | ----------------------------------------------------------- | ------------- |
| +          | 이항 산술 연산자         | 덧셈                                                        | X             |
| -          | 이항 산술 연산자         | 뺄셈                                                        | X             |
| +          | 이항 산술 연산자         | 곱셈                                                        | X             |
| /          | 이항 산술 연산자         | 나눗셈                                                      | X             |
| %          | 이항 산술 연산자         | 나머지                                                      | X             |
| ++         | 단항 산술 연산자         | 증가                                                        | O             |
| --         | 단항 산술 연산자         | 감소                                                        | O             |
| +          | 단항 산술 연산자         | 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다.        | X             |
| -          | 단항 산술 연산자         | 양수를 음수로, 음수를 양수로 반전한 값을 반환한다.          | X             |
| +          | 문자열 연결 연산자       | 피연산자중 하나 이상이 문자열인 경우 문자열로 연결          | X             |
| =          | 할당 연산자              | 우항에 있는 피연산자의 평가결과를 좌항에 할당               | O             |
| +=         | 할당 연산자              | 우항에 있는 피연산자의 평가결과를 좌항에 할당               | O             |
| -=         | 할당 연산자              | 우항에 있는 피연산자의 평가결과를 좌항에 할당               | O             |
| \*=        | 할당 연산자              | 우항에 있는 피연산자의 평가결과를 좌항에 할당               | O             |
| /=         | 할당 연산자              | 우항에 있는 피연산자의 평가결과를 좌항에 할당               | O             |
| %=         | 할당 연산자              | 우항에 있는 피연산자의 평가결과를 좌항에 할당               | O             |
| ==         | 동등/일치 비교 연산자    | 동등 비교                                                   | X             |
| ===        | 동등/일치 비교 연산자    | 일치 비교                                                   | X             |
| !=         | 동등/일치 비교 연산자    | 부동등 비교                                                 | X             |
| !==        | 동등/일치 비교 연산자    | 불일치 비교                                                 | X             |
| >          | 대소 관계 비교 연산자    | 크다                                                        | X             |
| <          | 대소 관계 비교 연산자    | 작다                                                        | X             |
| >=         | 대소 관계 비교 연산자    | 크거나 같다                                                 | X             |
| <=         | 대소 관계 비교 연산자    | 작거나 같다                                                 | X             |
| ? :<br>    | 삼항 조건 연산자         |                                                             | X             |
| \|\|       | 논리 연산자              | 논리합(OR)                                                  | X             |
| &&         | 논리 연산자              | 논리곱(AND)                                                 | X             |
| !          | 논리 연산자              | 부정(NOT)                                                   | X             |
| ,          | 쉼표 연산자              | 왼쪽 연산자부터 차례로 피연산자 평가.                       | X             |
| ()         | 그룹 연산자              | 그룹화하여 연산 우선순위 지정                               | X             |
| typeof     | typeof 연산자            | 값의 타입을 평가하여 문자열로 반환                          | X             |
| \*\*       | 지수 연산자              | 거듭 제곱                                                   | X             |
| ?.         | 옵셔널 체이닝 <br>연산자 |                                                             | X             |
| ??         | null 병합 연산자         |                                                             | X             |
| delete     | 프로퍼티 삭제            |                                                             | O             |
| new        | 뉴 연산자                | 생성자 함수를 호출할 때 사용하여 인스턴스를 생성            | X             |
| instanceof | 인스턴스 여부 판별       | 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별 | X             |
| in         | 프로퍼티 확인 연산       | 프로퍼티 존재 확인                                          | X             |

### 7.1.1 이항 산술 연산자

- 모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수 효과가 없다. 어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우는 없고 언제나 새로운 값을 만든다.

### 7.1.2 단항 산술 연산자

- 증가/감소 연산자는 피연자의 값을 변경하는 부수 효과가 있음
- `-` 단항 연산자는 피연산자의 부호를 반전한 값을 반환한다.
  - 특이케이스
    - 문자열을 숫자로: `-'10'; // -10`
    - 불리언 값을 숫자로: `-true; // -1`
    - 문자열은 숫자로 타입 변환할 수 없으므로 NaN 반환: `-'Hello'; // NaN`

### 7.1.3 문자열 연결 연산자

- 9장 '타입 변환과 단축 평가'에서 자세히

## 7.2 할당 연산자

- 여러 변수에 동일한 값을 연쇄 할당할 수 있다.
  - `a = b = c = 0;`

## 7.3 비교 연산자

### 7.3.1 동등/일치 비교 연산자

- 동등 비교 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치 시킨 후 같은 값인지 비교한다.
  - ❓느려지는지 확인해보자
    - 타입 확인이 있기 떄문에 무조건 차이남

```Javascript
// 동등 비교
console.log(5 == '5'); // true, 문자열 '5'가 숫자 5로 변환됩니다.
// 일치 비교
console.log(5 === '5'); // false, 타입이 다릅니다.
// 성능 측정
console.time('동등 비교');
for (let i = 0; i < 1000000; i++) {
  5 == '5';
}
console.timeEnd('동등 비교');

console.time('일치 비교');

for (let i = 0; i < 1000000; i++) {
  5 === '5';
}

console.timeEnd('일치 비교');

// 결과
// 동등 비교: 9.242919921875 ms
// 일치 비교: 2.4609375 ms
// 엔진 내 최적화의 영향을 받아 성능차이가 미미하다.
```

- 일치 비교 연산자 주의사항
  - Nan은 자신과 일치하지 않는다. `NaN === NaN; // false`
    - Number.isNaN()으로 비교하거나 Object.is(a, b) 로 비교
  - 숫자 0 조심: 양의 0과 음의 0 은 일치한다.

### 7.3.2 대소 관계 비교 연산자

## 7.4 삼항 조건 연산자

- 만약 조건식의 평과 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환된다.
- 삼항 조건 연산자의 표현식은 값으로 평가할 수 있는 표현식인 문이다.

## 7.5 논리 연산자

- 논리 연산이 복잡할 때는 '드모르간의 법칙'을 사용하면 좋다.
  - ❓드모르간의 법칙 조사
    - 논리 연산의 순서를 바꾸고, 부정 연산의 위치를 바꾸는 것만으로 동일한 의미를 표현할 수 있습니다.

```Javascript
// 로그인 성공 여부를 확인하는 코드
const isValidToken = true;
const isValidUser = true;

// 드모르간의 법칙을 사용하여 조건문을 간결하게 표현
const isLoginSuccess = !isValidToken || !isValidUser;

// 기존 코드와 동일한 의미
console.log(isLoginSuccess === !(isValidToken && isValidUser)); // true
```

## 7.6 쉼표 연산자

## 7.7 그룹 연산자

## 7.8 typeof 연산자

- typeof 연산자 반환 타입 문자열
  - string
  - number
  - boolean
  - undefined
  - symbol
  - object
  - function
  - ❓ BigInt 어떻게 되는지 조사: 'bigint'로 찍힌다고 한다.
- null 값을 연산하면 'null'이 아닌 'object' 반환된다.
- 선언하지 않은 식별자를 연산하면 'undefined' 반환된다.
- BigNumber.js 를 쓰는게 맞다

## 7.9 지수 연산자

- 음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호로 묶어야 한다.
  - `(-5) ** 2; // -25`
- 지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다.

## 7.10 그 외 연산자

- 별도 장에서 다룰 예정

## 7.11 연산자의 부수 효과

- 부수 효과가 있는 연산자는 할당 연산자(=), 증가/감소 연산자(++/--), delete 연산자다.

## 7.12 연산자의 우선순위

- 그냥 그룹 연산자 열심히 쓰는게 좋다.

## 7.13 연산자 결합 순서

# 8장 제어문

- 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.

## 8.1 블록문

- 0개 이상의 문을 중괄호로 묶은 것
- 자바스크립트는 블록문을 하나의 실행 단위로 취급
- 블록문은 언제나 자체 종결성을 갖기에 세미콜론이 맨 끝에 추가되지 않는다.

## 8.2 조건문

- 주어진 조건식의 평가 결과(불리언 값만 취급)에 따라 코드 블록의 실행을 결정

### 8.2.1 if ... else 문

- 만약 불리언 값이 아닌 값으로 평가되면 자바스크립트 엔진이 강제 변환한다.

## 8.2.2 switch 문

- break문을 잘 사용하자
- default에는 일반적으로 break문을 사용하지 않는다.
- 가독성의 기준에서 if 문을 대체하여 사용 가능하다.

## 8.3 반복문

- 조건식의 평과 결과가 참인 경우 코드 블록을 실행하고, 조건식이 거짓일 때까지 반복된다.

### 8.3.1 for 문

- for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이다. 다 없으면 무한루프가 된다. while(true)와 동일

### 8.3.2 while 문

- 반복횟수가 불명확할 때 주로 사용된다.

### 8.3.3 do ... while 문

## 8.4 break 문

- 코드 블록을 탈출시킨다.
- 레이블문이란 식별자가 붙은 문을 말한다. `foo: console.log('foo');`
  - 중첩된 for문 외부로 탈출할 때 유용하고 그외에는 권장되지 않는다. 코드 흐름 복잡도가 높아짐

## 8.5 continue 문
