# 9장 - 타입 변환과 단축 평가

## 9.1 타입 변환이란?

- 명시적 타입 변환(explicit coercion) 또는 타입 캐스팅
- 암묵적 타입 변환(implicit coercion) 또는 타입 강제 변환(type coercion)
- 타입 변환 결과를 예측하지 못하거나 예측 결과와 일치하지 않는다면 오류를 생산할 가능성이 높아진다.

## 9.2 암묵적 타입 변환

### 9.2.1 문자열 타입으로 변환

```Javascript

// 숫자 타입
0 + '' // "0"
-0 + '' // "0"
1 + '' // "1"
-1 + '' // "-1"
NaN + '' // "NaN"
Infinity + '' // "Infinity"
-Infinity + '' // "-Infinity"

// 불리언 타입
true + '' // "true"
false + '' // "false"

// null 타입
null + '' // "null"

// undefined 타입
undefined + '' // "undefined"

// 심벌 타입
(Symbol()) + '' // Type Error

// 객체 타입
({}) + '' // "[Object object]"
Math + '' // "[object Math]"
[] + '' // ""
[10, 20] + '' // "10,20"
(function(){}) + '' // "function(){}"
Array + '' // "function Array(){ {native code} }"

```

### 9.2.2 숫자 타입으로 변환

```Javascript
// 문자열 타입
+'' // 0
+'0' // 0
+'1' // 1
+'string' // NaN

// 불리언 타입
+true // 1
+false // 0

// null 타입
+null // 0

// undefined 타입
+undefined // NaN

// 심벌 타입
+Symbol() // TypeError

// 객체 타입
+{} // NaN
+[] // 0
+[10, 20] // NaN
+(function(){}) // NaN

```

### 9.2.3 불리언 타입으로 변환

- Falsy값
  - false
  - undefined
  - null
  - 0, -0
  - NaN
  - ''
- Falsy 값 이외의 모든 값은 Truthy다.

## 9.3 명시적 타입 변환

### 9.3.1 문자열 타입으로 변환

```Javascript

// 1. String 생성자로 호출
String(1); // "1"

// 2. Object.prototype.toString 메서드 사용하는 방법
(1).toString(); // "1"

// 3. 문자열 연결 연산자를 이용하는 방법
1 + ''; // "1"

```

### 9.3.2 숫자 타입으로 변환

```Javascript
// 1. Number 생성자 함수 호출
Number(1); // "1"

// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)
parseInt(1); // "1"

// 3. + 단한 산술 연산자를 이용하는 방법
+'1'; // "1"

// 4. * 산술 연산자를 이용하는 방법
'0' * 1 // "0"
'1' * 1 // "1"

```

### 9.3.3 불리언 타입으로 변환

```Javascript

// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
Boolean('x') // true

// 2. ! 부정 논리 연산자를 두 번 사용하는 방법
!!'x'; // true

```

## 9.4 단축 평가

### 9.4.1 논리 연산자를 사용한 단축 평가

```Javascript
'Cat' && 'Dog' // "Dog"
'Cat' || 'Dog' // "Cat"
```

- 논리곱 연산자(&&)와 논리합 연산자(||)는 이처럼 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다.
- 단축평가(short-circuit evaluation)는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하여 단축하는 것을 말한다.
- 단축 평가를 유용하게 사용할 수 있는 상황
  - 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티 참조할 때 `var value = elem && elem.value;`
  - 함수 매개변수에 기본값을 설정할 때

### 9.4.2 옵셔널 체이닝 연산자(?.)

- 옵셔널 체이닝 연산자가가 도입되기 이전에는 논리 연산자 &&을 사용한 단축 평가를 통해 변수가 null 또는 undefined 인지 확인했다.
- 옵셔널 체이닝 연산자는 좌항 피연산자가 Falsy여도 null 또는 undefined 가 아니면 우항의 프로퍼티 참조를 이어간다.

### 9.4.3 null 병합 연산자(??)

- null 병합 연산자가 도입되기 이전에는 노리 연산자 || 를 사용한 단축 평가를 통해 변수에 기본값을 설정했다.
- null 병합 연산자는 좌항 피연산자가 Falsy 여도 null 또는 undefined가 아니면 좌항의 피연산자를 그대로 반환한다.

# 10장 - 객체 리터럴

## 10.1 객체란?

- 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이지만 객체 타입의 값, 즉 객체는 변경 가능한 값이다.
- 프로퍼티값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다.
- ❓ 메서드와 함수의 차이에 대해 토끼굴을 파보자
  - 함수: 독립적으로 존재하며, 입력을 받아 결과를 반환하는 코드의 묶음. 절차 지향 혹은 함수형에서 많이 사용.
    - 독립성: 어디에 속하지 않고 독립적임
    - 범용성: 프로그램 전체에서 호출 가능하고 재사용 가능.
    - 언어 요소: 많은 프로그래밍 언어의 기본 구성 요소
  - 메서드: 클래스나 객체에 속한 함수로, 객체의 상태를 조작하거나 객체의 행동을 정의하는데 사용. OOP에서 많이 사용.
    - 객체 지향: OOP의 컨텍스트에서 사용됨
    - 접근과 상호작용: 객체의 상태를 조회, 수정하는데 사용됨
    - 캡슐화와 상속: 객체 지향의 핵심 개념인 캡슐화, 상속 등과 밀접하게 연관됨.

## 10.2 객체 리터럴에 의한 객체 생성

- 객체 생성 방식 5가지
  - 객체 리터럴
  - Object 생성자 함수
  - 생성자 함수
  - Object.create 함수
  - 클래스
- 객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다는데 주의. 마지막에 세미콜론 붙는다.

## 10.3 프로퍼티

- 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.
- 심벌 값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용한다.
- 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다.
- `var, function` 같은 예약어를 프로퍼티 키로 상요해도 에러가 발생하지 않는다.
  - ❓어디까지 예약어고 어디까지 키워드지?
    - 그냥 저자가 오타낸 듯

## 10.4 메서드

- 메서드는 객체에 묶여있는 함수를 말한다.

## 10.5 프로퍼티 접근

- 두가지 방법
  - 마침표 표기법(dot notation)
  - 대괄호 표기법(bracket notation)
- 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열
  - 따옴표로 감싸지 않은 이름을 프로퍼티 키로 사용하면 자바스크립트 엔진은 식별자로 해석한다.
- 객체에 존재하지 않는 프로퍼티에 접근하면 undefined를 반환한다.(no error)
- `person.last-name` 변수에 대한 node와 브라우저의 다른 반응. 브라우저의 전역객체에 영향받음(name)
  - node: ReferenceError: name is not defined
  - 브라우저: NaN

## 10.6 프로퍼티 값 갱신

## 10.7 프로퍼티 동적 생성

## 10.8 프로퍼티 삭제

- 만약 존재하지 않는 프로퍼티를 삭제(delete)해도 아무런 에러 없이 무시됨

## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

### 10.9.1 프로퍼티 축약 표현

- 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략(property shorthand) 할 수 있다.

### 10.9.2 계산된 프로퍼티 이름

- 대괄호를 통해 동적으로 합친 문자열을 키로 사용가능

### 10.9.3 메서드 축약 표현

- function 키워드를 생략한 축약 표현을 사용 가능

## 11장 원시 값과 객체의 비교

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

- 원시 타입의 원시 값은 변경 불가능한 값이다.
- 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술인 점을 주의하자
- 원시값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

## 11.1.2 문자열과 불변성

- 원시 타입 문자열은 자바스크립트의 장점 중 하나다.
- 문자열은 유사 배열 객체이면서 이터러블 이므로 배열과 유사하게 각 문자에 접근할 수 있다.
  - 원시 값을 객체처럼 사용하면 원시값을 감싸는 래퍼 객체로 자동 변환된다. 21.3절 원시 값과 래퍼 객체에서 더 살펴볼 예정

### 11.1.3 값에 의한 전달

- 타 언어에서의 값에 의한 전달, 참조에 의한 전달과 다르다. 좀 더 정확히는 '공유에 의한 전달'이라고 표현하는 편이 좋다고 생각한다.(작가)
- 엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기 떄문. 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.

## 11.2 객체

- 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.
- 사용하기 매우 편리하지만 성능 면에서는 이론적으로 클래스 기반 객체지향 프로그래밍 언어의 객체보다 생성과 프로퍼티 접근에 비용이 더 많이 드는 비효율적인 방식이다.
- V8 엔진에서는 동적탐색 대신 히든 클래스라는 방식을 사용해 C++객체의 프로퍼티에 접근하는 정도의 성능을 보장한다.
- ❓Fast properties in V8 참고하여 더 알아보자
  - [TOAST 아티클 - 자바스크립트 성능의 비밀](https://ui.toast.com/posts/ko_20210909)
  - V8엔진 아키텍쳐: 소스 코드 -> 파서 -> Ignition 인터프리터 -> 바이트 코드 -> Turbofan 컴파일러 -> 최적화 코드
    - 즉, 모든 js를 한번 인터프리터로 바이트 코드로 다 바꾸고 -> 바이트 코드 내에서 일부 코드를 최적화 하는 것
  - 거의 모든 프로그래밍 언어는 AST(추상구문트리)를 이용해서 상위 수준의 코드 표현을 하위 수준의 표현으로 변환한다.
  - 히든 클래스를 활용한 성능 최적화 객체
    - 프로퍼티의 순서와 네임을 기록해서 재사용 가능하게 갖춰 둠으로써 성능이 매우 빨라 진다.
    - js의 성능 향상을 최대화 하려면 동적 프로퍼티 추가를 줄여야 할 수 있다.
    - 히든 클래스는 개발자 콘솔에서 볼 수 있다. @number 이런식으로 넘버링 되있다.
      - [참고](https://velog.io/@sosoyim/%EC%A0%9C%EB%A9%8B%EB%8C%80%EB%A1%9C-JS-%EA%B0%9D%EC%B2%B4-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A5%BC-%EC%9D%BD%EC%96%B4%EB%82%B4%EB%8A%94-%EB%B2%95feat.V8-Hidden-Class)

### 11.2.1 변경 가능한 값

- 객체는 변경 가능한 값이다. 재할당 없이 객체를 직접 변경할수 있다. 동적으로 프로퍼티 추가나 값 갱신도 되고 프로퍼티의 삭제도 가능하다.
- 메모리를 효율적으로 사용하기 위해 그리고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 강능한 값으로 설계되어 있다. 메모리 사용의 효율성과 성능을 위해 어느정도 구조적인 단점을 감안한 설계이다.
- 원시값과 다르게 식별자가 하나의 객체를 공유할 수 있다.
- ❓ 얕은 복사와 깊은 복사의 수단들을 알아보자
  - 얕은 복사
    - Spread 연산자 `{ ...obj }`
    - Object.assign
    - Array.slice()
    - Array.concat()
  - 깊은 복사
    - JSON.stringlify(), JSON.parse()
    - 재귀 함수
    - 라이브러리 사용
      - Lodash cloneDeep

### 11.2.2 참조에 의한 전달

- 값에 의한 전달과 참조에 의 한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있ㄴ은 값ㄱ을 복사해서 전달한다는 면에서 동일하다.
- 자바스크립트에는 '참조에 의한 전달'은 존재하지 않고 '값에 의한 전달'만이 존재한다고 말할 수 있다.
  - ❓ 좀 더 알아보자
    - 객체의 경우, 변수에는 객체의 실제 값이 아닌 참조가 저장되므로, 이 참조를 통해 원본 객체를 수정할 수 있다. 이러한 특성 때문에 때때로 '참조에 의한 전달'처럼 느껴질 수 있지만, 기본적으로 JavaScript의 모든 전달 방식은 '값에 의한 전달' 이다.
    - 즉 다른 언어는 참조에 의한 전달을 할 경우, 참조의 값을 수정하면 원본도 수정되는데 JS는 아니다. 참조처럼 보이는 객체를 매개변수로 전달해도 결국 주소 값만 복사해서 보내니 원본 수정이 될 뿐이다. 결국 값에 의한 전달만 하는 격이다.
