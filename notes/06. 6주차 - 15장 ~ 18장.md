# 15장 let, const 키워드와 블록 레벨 스코프

## 15.1 var 키워드로 선언한 변수의 문제점

### 15.1.1 변수 중복 선언 허용

### 15.1.2 함수 레벨 스코프

- 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.

### 15.1.3 변수 호이스팅

## 15.2 let 키워드

### 15.2.1 변수 중복 선언 금지

### 15.2.2 블록 레벨 스코프

### 15.2.3 변수 호이스팅

- let 키워드로 선언한 변수는 '선언 단계'와 '초기화 단계'가 분리되어 진행된다.
- 스코프 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각 지대(Temporary Dead Zone)이라고 부른다.
- ES6에서 도입된 let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.

### 15.2.4 전역 객체와 let

- let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.

## 15.3 const 키워드

### 15.3.1 선언과 초기화

- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.

### 15.3.2 15.3.2 재할당 금지

### 15.3.3 상수

### 15.3.4 const 키워드와 객체

- const 키워드로 선언된 변수에 객체를 할당한 경우 값은 변경할 수 있다. 재할당 금지가 값의 불변을 의미하지는 않는다.

## 15.4 var vs let vs const

# 16장 프로퍼티 어트리뷰트

## 16.1 내부 슬롯과 내부 메서드

- 내부 슬롯: 의사 프로퍼티(pseudo property)
- 내부 메서드: 의사 메서드(pseudo property)
- 둘다 내부 로직이므로 접근할 수 없다.
- 간접 접근만 `__proto__`로 가능하다.

## 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

- JS 엔진이 프로퍼티를 생성할 떄 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.
- 내부 슬롯: `[[Value]] [[Writable]] [[Enumerable]] [[Configurable]]`
- Object.getOwnPropertyDescriptor 로 간접 확인 가능

## 16.3 데이터 프로퍼티와 접근자 프로퍼티

- 데이터 프로퍼티: 키와 값으로 구성된 일반적인 프로퍼티.
- 접근자 프로퍼티: 자체적으로는 값을 갖지 않고 데이터 프로퍼티의 값을 읽거나 저장할 떄(get/set) 호출되는 접근자 함수로 구성된 프로퍼티

### 16.3.1 데이터 프로퍼티

| 프로퍼티 <br>어트리뷰트 | 프로퍼티 <br>디스크립터 <br>객체의 프로퍼티 | 설명                                                                                                                                                                                                                                                  |
| ----------------------- | ------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `[[Value]]`             | value                                       | - 프로퍼티 키를 통해 접근하면 반환 되는 값<br>- 키를 통해 값을 변경하면 값을 재할당 한다. 이 때 프로퍼티가 없으면 값을 동적 생성하고 생성한 프로퍼티의 `[[Value]]`에 값을 저장환다.                                                                   |
| `[[Writable]]`          | writable                                    | - 프로퍼티의 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다.<br>- 값이 false 인 경우 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.                                                                                                                |
| `[[Enumerable]]`        | enumerable                                  | - 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다.<br>- false 인 경우 for .. in 이나 Object.keys 메서드등으로 열거할 수 없다.                                                                                                                 |
| `[[Configurable]]`      | configurable                                | - 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다. <br>- false 인 경우 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단 `[[Writable]]`이 true인 경우 `[[Value]]` 의 변경과 `[[Writable]]`을 false로 바꾸는 것은 허용된다. |

### 16.3.2 접근자 프로퍼티

| 프로퍼티 <br>어트리뷰트 | 프로퍼티 <br>디스크립터 <br>객체의 프로퍼티 | 설명                                                                                                                                                                       |
| ----------------------- | ------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `[[Get]]`               | get                                         | - 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수<br>- 데이터 프로퍼티의 키로 값에 접근하면 값에 접근하기 전에 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환됨 |
| `[[Set]]`               | set                                         | - 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수<br>- 값을 저장하면 setter를 통해 그 결과가 값으로 저장된다.                                                        |
| `[[Enumerable]]`        | enumerable                                  | 데이터 프로퍼티의 enumerable과 같다.                                                                                                                                       |
| `[[Configurable]]`      | configurable                                | 데이터 프로퍼티의 configurable과 같다.                                                                                                                                     |

## 16.4 프로퍼티 정의

- 새로운 프로퍼티를 추가하며 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것
- Object.defineProperty 메서드를 사용한다.
- 프로퍼티 디스크립터 객체의 기본값

| 프로퍼티 디스크립터 객체의 프로퍼티 | 대응하는 프로퍼티 어트리뷰트 | 기본값    |
| ----------------------------------- | ---------------------------- | --------- |
| value                               | `[[Value]]`                  | undefined |
| get                                 | `[[Get]]`                    | undefined |
| set                                 | `[[Set]]`                    | undefined |
| writable                            | `[[Writable]]`               | false     |
| enumerable                          | `[[Enumerable]]`             | false     |
| configurable                        | `[[Configurable]]`           | false     |

## 16.5 객체 변경 방지

| 구분           | 메서드                   | 추가 | 삭제 | 값 읽기 | 값 쓰기 | 재정의 |
| -------------- | ------------------------ | ---- | ---- | ------- | ------- | ------ |
| 객체 확장 금지 | Object.preventExtensions | X    | O    | O       | O       | O      |
| 객체 밀봉      | Object.seal              | X    | X    | O       | O       | X      |
| 객체 동결      | Object.freeze            | X    | X    | O       | X       | X      |

- 진짜 불변 객체 만들고 싶으면 deepFreeze 하도록 타고 들어가서 다 얼려라

❓ 위 방식을 활용한 프로퍼티 상속 예시

```Javascript
function Animal(name, emoji) {
  this.name = name;
  this.emoji = emoji;
}

Animal.prototype.printName = function () {
  console.log(`${this.emoji} ${this.name}`);
};

function Dog(name, emoji, owner) {
  Animal.call(this, name, emoji);
  this.owner = owner;
}

// Dog.prototype = Object.create(Object.prototype);
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;
Dog.prototype.play = () => {
  console.log('play with');
};

function Tiger(name, emoji) {
  Animal.call(this, name, emoji);
}

Tiger.prototype = Object.create(Animal.prototype);
Tiger.prototype.hunt = () => {
  console.log('hunt');
};

const dog1 = new Dog('멍멍', '🐕', 'ted');
dog1.play();
dog1.printName();

const tiger = new Tiger('어흥', '🐯');
tiger.printName();
tiger.hunt();

```

# 17장 생성자 함수에 의한 객체 생성

## 17.1 Object 생성자 함수

- new Object()
- 빌트 인 생성자 함수: String, Number, Boolean, Function, Array, Date, RegExp, Promise

## 17.2 생성자 함수

### 17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점

- 재활용이 어렵다(객체 마다 프로퍼티가 같은 경우가 많다)

### 17.2.2 생성자 함수에 의한 객체 생성 방식의 장점

- 재활용 쉬움
- 다만 new 연산자 없이 호출이 되는데, 이때 그냥 일반 함수로 동작한다. 네이밍 컨벤션 중요한 이유.
- ❓ this 바인딩이 어느 시점에 되는지? js 엔진 or 런타임.
  - 런타임 전(책좀 똑바로 봐라)

### 17.2.3 생성자 함수의 인스턴스 생성 과정

1. 인스턴스 생성과 this 바인딩
   1. 바인딩: 식별자와 값을 연결하는 과정
2. 인스턴스 초기화
3. 인스턴스 반환: 인스턴스가 바인딩된 this를 암묵적으로 반환

### 17.2.4 내부 메서드 `[[Call]]`과 `[[Construct]]`

- 함수 객체도 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가지고 있기 떄문에 호출 가능

### 17.2.5 constructor와 non-constructor 의 구분

- 함수 정의 방식에 따라 구분
  - constructor: 함수 선언문, 함수 표현식, 클래스(클래스도 함수)
  - non-constructor: 메서드(ES6 축약표현), 화살표 함수
    - `const obj = { x() {} };`

### 17.2.6 new 연산자

- new로 호출된 함수는 `[[Call]]`이 아닌 `[[Construct]]`가 호출된다.

### 17.2.7 new.target

- 생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위한 방식 ES6 new.target

# 18장 함수와 일급 객체

## 18.1 일급 객체

조건 4가지

1. 무명의 리터럴로 생성 가능, 런타임에 생성 가능해야하기 때문에 무명이 되야한다
2. 변수나 자료구조에 저장 가능
3. 함수 매개변수에 전달 가능
4. 함수의 반환값으로 사용 가능

## 18.2 함수 객체의 프로퍼티

- arguments, caller, length, name, proptotype

### 18.2.1 arguments 프로퍼티

- 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한(iterable) 유사 배열 객체. 함수 내부의 지역변수처럼 사용 된다.
- 함수 호출시 매개변수와 인수의 개수가 일치하는지 확인 안함
- 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고 undefined로 초기화 된 이후 인수가 할당 된다.
- 초과된 인수는 무시
- arguments 객체의 Symbol(Symbol.iterator) 프로퍼티는 arguments를 순회 가능한 객체로 만들기 위한 프로퍼티다.
- 이터러블이 도입된건 ES6부터임.
- 유사 배열 객체는 배열이 아니다. 배열 메서드 그냥 쓰면 에러 발생한다. 요즘은 Rest parameter 쓰면 된다.

### 18.2.2 caller 프로퍼티

- 비표준 라이브러리. 브라우저에서만 동작하는 편

### 18.2.3 length 프로퍼티

- 매개변수 개수

### 18.2.4 name 프로퍼티

- 그냥 이름
- 기명 익명에서 익명은 ES5에서는 빈문자열,

### 18.2.5 `__propto__` 접근자 프로퍼티

- 객체지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킴.

### 18.2.6 prototype 프로퍼티

- 함수가 객체를 생성하는 생성자 함수로 호출될 때 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킴
