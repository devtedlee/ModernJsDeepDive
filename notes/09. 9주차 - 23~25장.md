# 23장 - 실행 컨텍스트

## 23.1 소스코드의 타입

소스코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르다.

1. 전역 코드:
   1. 전역 스코프를 생성해야한다.
   2. var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수가 전역 객체에 연결 되어야 한다. 전역 객체의 프로퍼티와 메서드로 바인딩 하고 참조하기 위해서다.
   3. 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다.
2. 함수 코드
   1. 지역 스코프를 생성한다.
   2. 생성한 지역 스코프는 전역 스코프의 스코프 체인 일원으로 연결 해야한다.
   3. 함수 코드가 평가되면 함수 실행 컨텍스트가 생성된다.
3. eval 코드
   1. stict mode에서 자신만의 독자적인 스코프를 생성한다.
   2. eval 코드가 평가되면 eval 실행 컨텍스트가 생성된다.
4. 모듈 코드
   1. 모듈별로 독립적인 모듈 스코프를 생성한다.
   2. 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다.

## 23.2 소스코드의 평가와 실행

- 자바스크립트 엔진은 소스코드를 2단계인 평가와 실행으로 나누어 처리한다.
- 평가의 결과 실행 컨텍스트가 생겨난다.
- 소스코드의 실행에 실행 컨텍스트가 계속 활용된다.

## 23.3 실행 컨텍스트의 역할

실행 컨텍스트가 관리하는 것

1. 선언에 의해 생성된 모든 식별자를 스코프를 구분하여 등록. 상태변화(식별자에 바인딩된 값의 변화)를 지속 관리해야 한다.
2. 스코프는 중첩관계에 의해 스코프 체인을 형성한다. 체인을 통해 상위 스코프로의 식별자 검색이 필수적이다.
3. 실행중인 코드의 실행 순서를 동적으로 변경할 수 있어야 한다. 다시 롤백도 되야 한다.

모든 코드는 실행 컨텍스트에 의해 관리된다.

## 23.4 실행 컨텍스트 스택

- 코드의 실행 순서를 관리한다.
- 스택 자료구조 형태로 구성되어 있다. 스택에는 실행 컨텍스트들이 담긴다.
- 실행 컨텍스트 최상위에는 항상 현재 실행중인 코드의 실행 컨텍스트가 있다.

## 23.5 렉시컬 환경

- 스코프와 식별자를 관리한다.
- 키와 값을 갖는 객체 형태의 스코프를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다.
- 렉시컬 환경의 구성
  - EnvironmentRecord:환경 레코드
    - 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소
  - OuterLexicalEnvironmentReference: 외부 렉시컬 환경에 대한 참조
    - 상위 스코프를 가리키는 참조. 이 참조를 통해 단방향 링크드 리스트 자료구조 형태로 스코프 체인이 구현된다.

## 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

예제 코드

```Javascript
var x = 1;
const y = 2;

function foo (a) {
	var x = 3;
	const y = 4;
	function bar (b) {
		const z = 5;
		console.log(a + b + x + y + z)
	}
	bar(10);
}

foo(20) // 42
```

- 전역 객체 생성
- 전역 코드 평가
  - 전역 실행 컨텍스트 생성
  - 전역 렉시컬 환경 생성
    - 전역 환경 레코드 생성
      - 객체 환경 레코드 생성
      - 선언적 환경 레코드 생성
    - this 바인딩
    - 외부 렉시컬 환경에 대한 참조 결정
- 전역 코드 실행
- `foo` 함수 코드 평가
  - 함수 실행 컨텍스트 생성
  - 함수 렉시컬 환경 생성
    - 함수 환경 레코드 생성
    - this 바인딩
    - 외부 렉시컬 환경에 대한 참조 결정
- `foo` 함수 코드 실행
- `bar` 함수 코드 평가
  - 함수 실행 컨텍스트 생성
  - 함수 렉시컬 환경 생성
    - 함수 환경 레코드 생성
    - this 바인딩
    - 외부 렉시컬 환경에 대한 참조 결정
- `bar` 함수 코드 실행

- 모든 전역 변수가 전역 객체의 프로퍼티가 되는 ES6 이전에는 전역 객체가 전역 환경 레코드의 역할을 수행함
- 일반 함수의 this 바인딩은 전역 객체로 연결된다.
- 각 코드의 실행 종료와 함께 실행 컨텍스트 스택은 비워진다.

## 23.7 실행 컨텍스트와 블록레벨 스코프

- 전역에서 선언된 let,const 키워드는 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다. (전역에서 for문 쓰지 말아야되나..?)

# 24장 클로저

- 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다
- 클로저는 자바스크립트 고유의 개념이 아니다. 사양에도 없다.

## 24.1 렉시컬 스코프

- 자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다.
- 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 정해진다.

## 24.2 함수 객체의 내부 슬롯 `[[Environment]]`

- 함수는 자신의 내부 슬롯 `[[Environment]]` 에 상위 스코프의 참조(렉시컬 환경)를 저장한다.

## 24.3 클로저와 렉시컬 환경

- 클로저는 외부 함수보다 더 오래 유지되는 중첩 함수다. 중첩함수는 이미 생명주기가 종료된 외부 함수의 변수를 참조할 수 있다.
- 외부함수 A의 실행 컨텍스트가 pop되도, A가 활용중인 렉시컬 환경은 B중첩함수의 렉시컬 환경이 보유하고 있으므로, B중첩함수를 활용하는 실행컨텍스트를 통해 A의 렉시컬 환경을 여전히 사용할 수 있다.

## 24.4 클로저의 활용

- 상태를 안전하게 변경하고 유지하기 위해 활용
- 상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용한다.

## 24.5 캡슐화와 정보 은닉

- 캡슐화: 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다.
- 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 한다.
- 정보를 보호하고, 결합도를 낮추는 효과가 있다.

## 24.6 자주 발생하는 실수

- var 키워드를 써서 for문 돌리기. 함수 레벨 스코프를 갖다 보니 잘못 쓸 수 있음.
- let이나 const 쓰자.

# 25장 클래스

## 25.1 클래스는 프로토타입의 문법적 설탕인가?

- 맞다. 생성자 함수의 문법적 설탕이다.
- 하지만 정확히 동일하게 동작하지 않는다.
- 더 엄격하고, 추가 기능도 제공한다.
- 새로운 객체 생성 매커니즘으로 보는 것이 좀 더 합당하긴 하다.

|                      | 클래스                     | 생성자 함수      |
| -------------------- | -------------------------- | ---------------- |
| new 연산자 없이 호출 | 에러 발생                  | 일반 함수로 호출 |
| 상속 지원            | extends, super 키워드 제공 | X                |
| 호이스팅             | TDZ                        | 호이스팅 된다    |
| strict mode          | 암묵적 지정                | X                |
| 열거여부             | 안됨                       | 열거됨           |

## 25.2 클래스 정의

- 클래스는 표현식으로 정의된다.
- 클래스도 일급 객체다
- 클래스는 함수다.
- typeof 도 function이 뜬다
- 클래스와 생성자 함수 정의 방식 비교

```Javascript

// 생성자 함수 방식
var Person = (function () {
    // 생성자 함수
    function Person(name) {
        this.name = name;
    };

    // 프로토타입 메서드
    Person.prototype.sayHi = function () {
        console.log('Hi, I am ' + this.name);
    };

    // 정적 메서드
    Person.sayHello = function () {
        console.log('Hello!');
    }

    return Person;
}());

// 클래스 방식
class Person {
    // 생성자
    constructor(name) {
        this.name = name;
    }

    // 프로토타입 메서드
    sayHi() {
        console.log('Hi, I am ' + this.name);
    }

    // 정적 메서드
    static sayHello() {
        console.log('Hello!');
    }
}

```

## 25.3 클래스 호이스팅

- 클래스 선언문은 TDZ에 들어가 마치 호이스팅이 발생하지 않는 것처럼 동작한다.

## 25.4 인스턴스 생성

## 25.5 메서드

### 25.5.1 constructor

```Javascript
class Person {}

console.log(typeof Person); // function

```

- 클래스도 함수 객체 고유의 프로퍼티를 모두 갖고 있다.
- 클래스의 constructor 메서드와 프로토타입의 constructor 프로퍼티는 이름이 같아 혼동하기 쉽지만 직접적인 관련은 없다. 프로토타입의 controtuctor는 생성자 함수를 가리킨다.
- 클래스 constructor는 별도 반환문을 갖지 않는게 훨씬 좋다.
  - 생성자 함수와 동일하게 암묵적으로 this를 반환한다.
  - 만약 this 아닌 객체가 명시적으로 반환되면 진짜 this말고 명시한 객체가 반환된다.
  - 그리고 반환할 때 원시타입 반환하면 그냥 무시되고 this가 반환된다.
  - 클래스 기본동작 훼손하니까 되도록 하지 말자

### 25.5.2 프로토타입 메서드

### 25.5.3 정적 메서드

- 정적 메서드는 인스턴스로 호출 불가!
- 인스턴스의 프로토타입 체인 상에는 클래스가 존재하지 않기 때문에 인스턴스로 클래스의 메서드를 상속받을 수 없다.

### 25.5.4 정적 메서드와 프로토타입 메서드의 차이

1. 속해 있는 프로토타입 체인이 다르다.
2. 호출 방식이 다르다. 정적 -> 클래스. 프로토타입 -> 인스턴스
3. 인스턴스 프로퍼티 참조 가능 여부가 다르다. 정적 -> X, 프로토 타입 -> O

### 25.5.5 클래스에서 정의한 메서드 특징

1.  function 키워드 생략
2.  객체 리터럴과 다르게 여러개 정의할떄 콤마 필요 없음
3.  암묵적 strict mode
4.  열거 불가
5.  new 연산자와 함께 호출 불가. `[[Construct]]` 가 없어서다.

## 25.6 클래스의 인스턴스 생성 과정

- 17.2.3절 생성자 함수의 인스턴스 생성 과정과 유사하다.

## 25.7 프로퍼티

### 25.7.1 인스턴스 프로퍼티

- 이제 밖에서도 생성 되서 조금 정리 애매

### 25.7.2 접근자 프로퍼티

- getter, setter 같은 접근자 함수로 구성된 프로퍼티
- 클래스의 접근자 프로퍼티 또한 다른 클래스의 프로퍼티 메서드처럼 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 된다.

### 25.7.3 클래스 필드 정의 제안

- "이미 클래스 필드는 제안이 아니라 정식으로 생겼다."
- 클래스 필드에 함수를 할당하는것은 권장되지 않음. 클래스 필드에 함수를 할당하면 인스턴스 메서드가 되기 때문.

### 25.7.4 private 필드 정의 제안

- "이미 private 필드도 정식으로 생겼다."
- 접근 가능성 분류

| 접근 가능성               | public | private |
| ------------------------- | ------ | ------- |
| 클래스 내부               | O      | O       |
| 자식 클래스 내부          | O      | X       |
| 클래스 인스턴스 통한 접근 | O      | X       |

### 25.7.5 static 필드 정의 제안

- "이미 static 필드도 정식으로 생겼다."
- static private도 된다.

## 25.8 상속에 의한 클래스 확장

### 25.8.1 클래스 상속과 생성자 함수 상속

- 기존 클래스를 상속 받아 새로운 클래스를 확장하여 정의하는 것. `extends` 키워드 사용.

### 25.8.2 extends 키워드

### 25.8.3 동적 상속

```Javascript
function Base(a) {
	this.a = a;
}

function Base2 {}

let condition = true;

class Derived extends (condition ? Base1 : Base2) {}

console.log(derived instanceof Base1); // true
console.log(derived instanceof Base2); // false
```

- 이런식의 동적 상속 가능
- ❓ 문제가 될 예외 상황은 없을까?
  - 예측성과 가독성 저하, 디버깅 어려움, 성능 이슈(최적화 방해), 예상 못한 동작, 보편적인 구조 설계와의 충돌
  - 예상치 못한 동작: 상속받은 클래스가 내부적으로 프로퍼티나 특정 메서드를 통해 상태분기를 하고 있는데, 이런 분기가 누락된 채 동작하거나 하는 등의 문제 발생 가능
- ❓동적 상속에서는 super 문제가 없나?
  - 부모클래스 메서드끼리의 메서드명 불일치
  - 런타임 전 정확한 동작을 알 수 없음
  - 상속 체인이 복잡해짐.

### 25.8.4 서브클래스의 constructor

### 25.8.5 super 키워드

- super를 호출하면 수퍼클래스의 constructor를 호출한다.
- super를 참조하면 수퍼클래스의 메서드를 호출할 수 있다.

super 호출 주의 사항

- 서브 클래스에서 constructor를 실행하지 않는 경우 서브 클래스의 constructor는 반드시 super를 호출해야한다.
  - 서브 클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임하기 때문이다.
- 서브 클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다.
  - super가 호출되지 않으면 인스턴스가 생성되지 않고, this 바인딩도 할 수 없기 떄문이다.
- super는 반드시 서브클래스의 constructor에서만 호출한다. 다른데서 호출하면 에러 발생

super 참조 주의사항

- ES6의 메서드 축약표현으로 정의된 함수만 `[[HomeObject]]`를 갖는다.
  - `[[HomeObject]]` 는 자신을 바인딩 하고 있는 객체를 가리킨다.
- super 참조는 클래스의 전유물이 아니다. 객체 리터럴에서도 super 참조 사용할 수 있다.

### 25.8.6 상속 클래스의 인스턴스 생성 과정

1. 서브클래스의 super 호출
   1. 내부 슬롯 `[[ConstructorKind]]`: 다른 클래스를 상속받지 않는 클래스(and 생성자 함수)는 값이 'base', 상속 받았으면 'derived'
   2. 서브 클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다.
2. 수퍼클래스의 인스턴스 생성과 this 바인딩
   1. 생성은 수퍼 클래스에서 했을지 몰라도, new.target의 값은 서브 클래스가 생성한 것으로 처리 된다.
3. 수퍼클래스의 인스턴스 초기화
4. 서브클래스 constructor로의 복귀와 this 바인딩
   1. super가 호출되지 않으면 인스턴스가 생성되지 않고, this 바인딩도 할 수 없다.
5. 서브클래스의 인스턴스 초기화
6. 인스턴스 반환

### 25.8.7 표준 빌트인 생성자 함수 확장

- 확장해서 쓸 수 있다.

# 이번주 토끼굴 주제

- 호출 스택과 렉시컬 환경의 변화 추적
